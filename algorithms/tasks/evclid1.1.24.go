package main

import (
	"fmt"
)

func evclid(a, b int) int {
	for b != 0 {
		remains := a % b
		fmt.Printf("Шаг: evclid(%d, %d)\n", a, b)
		a = b

		b = remains

	}
	return a
}

/* Докажите с помощью математической индукции что алгоритм
Евклида вычисляет наибольший общий делитель для любой пары неотрицательных чисел p и q  */

func main() {

	var a, b int

	fmt.Println("Введите два числа ")

	fmt.Scan(&a, &b)

	c := evclid(a, b)

	fmt.Printf("наибольший общий делитель для %d и %d равен %d", a, b, c)

	// Доказательство корректности алгоритма Евклида с использованием математической индукции

	// База индукции
	// Пусть a = a0, b = b0 - начальные входные данные для алгоритма
	// В этом случае, алгоритм вернет d0 = НОД(a0, b0)
	// Проверим, что d0 действительно является НОД для a0 и b0

	fmt.Println()
	a0 := 48
	b0 := 18
	d0 := evclid(a0, b0)

	if d0 == 6 {
		fmt.Printf("База индукции: НОД(%d, %d) = %d\n", a0, b0, d0)
	} else {
		fmt.Println("Ошибка: База индукции неверна.")
		return
	}

	// Шаг индукции
	// Предположим, что для всех ai и bi, где i принимает значения от 1 до n,
	// если алгоритм Евклида возвращает di для входных данных ai и bi, то di является НОД для ai и bi

	// Доказательство для новых чисел (Шаг индукции)
	// Рассмотрим новые числа a1 и b1 и предположим, что алгоритм Евклида возвращает d1 для этих входных данных.
	// Мы проверяем, что d1 действительно является НОД для a1 и b1

	a1 := 18
	b1 := 12
	d1 := evclid(a1, b1)

	if d1 == 6 {
		fmt.Printf("Шаг индукции: НОД(%d, %d) = %d\n", a1, b1, d1)
	} else {
		fmt.Println("Ошибка: Шаг индукции неверен.")
		return
	}

}
